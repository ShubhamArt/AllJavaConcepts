1. S - Single Responsibility Principle (SRP)
A class should have only one reason to change, meaning it should only have one job or responsibility.

Real-world example: Imagine a Library class that handles two responsibilities: tracking books and generating reports on
library usage. According to SRP, these should be two separate classes, because the library might change how books are
managed, and the reporting system could change for different reasons.

2. O - Open/Closed Principle (OCP)
Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.

Real-world example: Think of an E-commerce system that applies different discounts to products.
Instead of modifying the Discount class every time a new discount type is added, you can extend it.

3. L - Liskov Substitution Principle (LSP)
Objects of a superclass should be replaceable with objects of a subclass without affecting the functionality of the
program.
Real-world example: Consider a Bird class with a subclass Penguin.
If the fly() method is part of the Bird class, penguins should not inherit it because they can't fly.

4. I - Interface Segregation Principle (ISP)
Clients should not be forced to depend on interfaces they do not use.
Real-world example: Imagine a Printer interface that includes methods like print_color(),
 scan(), and fax(). A simple DocumentPrinter might not need all these methods but would still be forced
 to implement them if the interface was combined.

 5. D - Dependency Inversion Principle (DIP)
 High-level modules should not depend on low-level modules. Both should depend on abstractions. Furthermore,
 abstractions should not depend on details. Details should depend on abstractions.
 Real-world example: Imagine a PaymentProcessing class that directly depends on a specific payment gateway (like Stripe). According to DIP, it should depend on an abstraction, not on the specific implementation.