1. S - Single Responsibility Principle (SRP)
A class should have only one reason to change, meaning it should only have one job or responsibility.

Real-world example: Imagine a Library class that handles two responsibilities: tracking books and generating reports on
library usage. According to SRP, these should be two separate classes, because the library might change how books are
managed, and the reporting system could change for different reasons.

In this example, the Library class has been split into two classes: Library and ReportGenerator, each having a single responsibility.

2. O - Open/Closed Principle (OCP)
Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.

Real-world example: Think of an E-commerce system that applies different discounts to products.
Instead of modifying the Discount class every time a new discount type is added, you can extend it.

This example uses different discount types (PercentageDiscount and FixedAmountDiscount) without modifying the Discount class.

3. L - Liskov Substitution Principle (LSP)
Objects of a superclass should be replaceable with objects of a subclass without affecting the functionality of the
program.
Real-world example: Consider a Bird class with a subclass Penguin.
If the fly() method is part of the Bird class, penguins should not inherit it because they can't fly.

Here, the Bird class is the base class, and the Sparrow and Penguin classes correctly override the move() method.

4. I - Interface Segregation Principle (ISP)
Clients should not be forced to depend on interfaces they do not use.
Real-world example: Imagine a Printer interface that includes methods like print_color(),
 scan(), and fax(). A simple DocumentPrinter might not need all these methods but would still be forced
 to implement them if the interface was combined.

In this example, different interfaces (PrintInterface, ScanInterface, FaxInterface) are created, so classes only implement what they need.

 5. D - Dependency Inversion Principle (DIP)
 High-level modules should not depend on low-level modules. Both should depend on abstractions. Furthermore,
 abstractions should not depend on details. Details should depend on abstractions.
 Real-world example: Imagine a PaymentProcessing class that directly depends on a specific payment gateway (like Stripe). According to DIP, it should depend on an abstraction, not on the specific implementation.